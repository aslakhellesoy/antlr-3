# SimpleCalcParser (SimpleCalc.g)
# Generated by ANTLR 3.1.1 on 2008-11-29 17:12:21

require 'SimpleCalcLexer'

class SimpleCalcParser
	attr_reader :lexer
	
    TOKENS = [
        ["NUMBER", 1],
        ["WS", 2],
        ["'+'", 3],
        ["'-'", 4],
        ["'*'", 5],
        ["'/'", 6],
        ["'('", 7],
        ["')'", 8]
    ].inject({}) { |hash, pair|
        name = pair[0]
        index = pair[1] + 3 # hardcoded for now... no way to get this value from ANTLR

        if name[0] == ?'
            hash[:"T#{index}"] = index
        else
            hash[:"#{name}"] = index
        end

        hash
    }
    
    TOKENS[:EOF] = -1

    def initialize(input)
        if input.respond_to?(:to_str) || input.respond_to?(:read)
            input = SimpleCalcLexer.new(input)
        end

		@lexer = input
        @input = TokenStream.new(input)
        @backtracking = 0
        @failed = false


    end

    # 15:1: parse : expression ;
    def parse()



        # 15:8: expression
        [SimpleCalc.expression,index=2,line=17]()




    end

    # 17:1: expression : mult ( '+' mult | '-' mult )* ;
    def expression()



        # 17:13: mult ( '+' mult | '-' mult )*
        [SimpleCalc.mult,index=3,line=28]()

        # 17:18: ( '+' mult | '-' mult )*
        while true
            alt1 = 3
            # 
            look_ahead1_0 = look_ahead(1)
            if look_ahead1_0 == :T__6  
                alt1 = 1
            elsif look_ahead1_0 == :T__7  
                alt1 = 2
            end
            case alt1
                when 1
                    # 18:5: '+' mult
                    match(:T__6)
                    [SimpleCalc.mult,index=3,line=28]()


                          @stack.push(@stack.pop + @stack.pop)
                        
                when 2
                    # 21:5: '-' mult
                    match(:T__7)
                    [SimpleCalc.mult,index=3,line=28]()


                          a = @stack.pop
                          b = @stack.pop
                          @stack.push(b - a)
                        
                else
                    break
            end
        end



    end

    # 28:1: mult : atom ( '*' atom | '/' atom )* ;
    def mult()



        # 28:7: atom ( '*' atom | '/' atom )*
        [SimpleCalc.atom,index=4,line=40]()

        # 28:12: ( '*' atom | '/' atom )*
        while true
            alt2 = 3
            # 
            look_ahead2_0 = look_ahead(1)
            if look_ahead2_0 == :T__8  
                alt2 = 1
            elsif look_ahead2_0 == :T__9  
                alt2 = 2
            end
            case alt2
                when 1
                    # 29:5: '*' atom
                    match(:T__8)
                    [SimpleCalc.atom,index=4,line=40]()


                          @stack.push(@stack.pop * @stack.pop)
                        
                when 2
                    # 32:5: '/' atom
                    match(:T__9)
                    [SimpleCalc.atom,index=4,line=40]()


                          a = @stack.pop
                          b = @stack.pop
                          @stack.push(b / a.to_f)
                        
                else
                    break
            end
        end



    end

    # 40:1: atom : (n= NUMBER | '(' expression ')' );
    def atom()
    	_n = nil




        # 40:5: (n= NUMBER | '(' expression ')' )
        alt3 = 2
        # 
        look_ahead3_0 = look_ahead(1)
        if look_ahead3_0 == :NUMBER  
            alt3 = 1
        elsif look_ahead3_0 == :T__10  
            alt3 = 2
        else
            raise "Expected: "
        end
        case alt3
            when 1
                # 40:7: n= NUMBER
                _n = @input.look_ahead(1)
                match(:NUMBER)
                 @stack.push(_n.text.to_i) 
            when 2
                # 41:5: '(' expression ')'
                match(:T__10)
                [SimpleCalc.expression,index=2,line=17]()

                match(:T__11)
        end



    end


      @stack = []

      def result
        @stack[0]
      end


    private

    class TokenStream
        attr_reader :index

        def initialize(input)
            @buffer = []
            @input = input
            @channel = nil

            @index = 0;
        end

        # returns a Token
        def look_ahead(pos)
            offset = @index + pos - 1

            while @buffer[-1] != :EOF && @buffer.length < offset + 1
                token = @input.next_token
                if token == :EOF || token.channel == @channel
                    @buffer << token
                end
            end

            offset = -1 if offset >= @buffer.length
            if offset < @buffer.length
                @buffer[offset]
            end
        end

        def mark
            @state = { :index => @index }
            return 0
        end

        def rewind(marker)
            @index = @state[:index]
        end

        def consume
           look_ahead(1) # force a read from the input if necessary
           @index = @index + 1
        end
    end

    def match(token = nil)
        if token.nil? || look_ahead(1) == token
            @input.consume
            @failed = false
            return
        elsif @backtracking > 0
            @failed = true
        else
            raise "Expected #{token}"
        end
    end

    def look_ahead(k)
        token = @input.look_ahead(k)
        if token != :EOF
            token = token.token_type
        end

        token
    end


end