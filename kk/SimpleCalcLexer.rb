# SimpleCalcLexer (SimpleCalc.g)
# Generated by ANTLR 3.1.1 on 2008-11-29 17:12:21

class SimpleCalcLexer
    require 'stringio'

	WS=5
	T__11=11
	T__10=10
	NUMBER=4
	EOF=-1
	T__9=9
	T__8=8
	T__7=7
	T__6=6
	
    def initialize(input)
        input = StringIO.new(input) if input.respond_to?(:to_str)
        @input = CharStream.new(input)
        @backtracking = 0
        @failed = false

    end

    def next_token
    	# TODO: catch exceptions
		@token = nil
		@channel = nil
		@text = nil

		@start = @input.index
		@line = @input.line
		@pos = @input.column

		@type = nil
		@type_int = nil

		return :EOF if @input.look_ahead(1) == :EOF

		match_Tokens()

		if @token == nil
			@text ||= @input.substring(@start, @input.index - 1)
			@token = Token.new(@type, @type_int, @line, @pos, @text, @channel)
		end

        return @token
    end

    class Token
        attr_reader :token_type
        attr_reader :int_type
        attr_reader :line
        attr_reader :pos
        attr_reader :text
        attr_reader :channel

        def initialize(token_type, int_type, line, pos, text, channel = nil)
            @token_type = token_type
            @int_type = int_type
            @line = line
            @pos = pos
            @text = text
            @channel = channel
        end

		alias :to_i :int_type
    end


    private

    class CharStream
        attr_reader :line
        attr_reader :column
        attr_reader :index

        def initialize(input)
            @buffer = ""
            @input = input
            @line = 1
            @column = 0

            @index = 0;
        end

        # returns a Fixnum between 0 and 0xFFFF or :EOF
        def look_ahead(pos)
            offset = @index + pos - 1
            if @buffer.length < offset + 1
                char = @input.read(offset + 1 - @buffer.length)
                @buffer << char if not char.nil?
            end

            if offset < @buffer.length
                @buffer[offset]
            else
                :EOF
            end
        end

        def mark
            @state = { :index => @index, :line => @line, :column => @column }
            return 0
        end

        def rewind(marker)
            @index = @state[:index]
            @line = @state[:line]
            @column = @state[:column]
        end

        def consume
           look_ahead(1) # force a read from the input if necessary
           @column = @column + 1
           if @buffer[@index] == ?\n
                @line = @line + 1
                @column = 0
           end
           @index = @index + 1
        end

        def substring(start, stop)
            @buffer.slice(start, stop - start + 1)
        end
    end


    def match(value = nil)
        @failed = false
        case
            when value.nil?
                @input.consume()
            when value.respond_to?(:to_str)
                catch(:done) do
                    value.each_byte do |c|
                        @failed ||= !(@input.look_ahead(1) == c)
                        @input.consume() if !@failed
                        throw :done if @failed
                    end
                end
            else
                @failed = !(@input.look_ahead(1) == value)
                @input.consume() if !@failed
        end

		if @failed && @backtracking <= 0
			raise "Expected #{value.respond_to?(:chr) ? value.chr : value}"
		end
    end

    def match_range(from, to)
        char = @input.look_ahead(1)

        if char != :EOF && (char >= from || char <= to)
			@failed = false
			match()
        elsif @backtracking > 0
            @failed = true
        else
            raise "Expected [#{from.chr}..#{to.chr}]"
        end
    end

    def match_T__6()

    		@type = :T__6
    		@type_int = T__6
    		# 7:8: '+'
    		match(?+)
    end

    def match_T__7()

    		@type = :T__7
    		@type_int = T__7
    		# 8:8: '-'
    		match(?-)
    end

    def match_T__8()

    		@type = :T__8
    		@type_int = T__8
    		# 9:8: '*'
    		match(?*)
    end

    def match_T__9()

    		@type = :T__9
    		@type_int = T__9
    		# 10:8: '/'
    		match(?/)
    end

    def match_T__10()

    		@type = :T__10
    		@type_int = T__10
    		# 11:9: '('
    		match(?()
    end

    def match_T__11()

    		@type = :T__11
    		@type_int = T__11
    		# 12:9: ')'
    		match(?))
    end

    def match_NUMBER()

    		@type = :NUMBER
    		@type_int = NUMBER
    		# 43:9: ( '0' .. '9' )+
    		# 43:9: ( '0' .. '9' )+
    		matchedOnce1 = false
    		while true
    		    alt1 = 2
    		    # 
    		    look_ahead1_0 = @input.look_ahead(1)
    		    look_ahead1_0 = -1 if look_ahead1_0 == :EOF
    		    if (look_ahead1_0 >= ?0 && look_ahead1_0 <= ?9)  
    		        alt1 = 1
    		    end
    		    case alt1
    		        when 1
    		            # 43:10: '0' .. '9'
    		            match_range(?0, ?9)
    		        else
    		            break
    		    end
    		    matchedOnce1 = true
    		end

    		if !matchedOnce1
    		    raise "Expected at least one match: 43:9: ( '0' .. '9' )+"
    		end
    end

    def match_WS()

    		@type = :WS
    		@type_int = WS
    		# 45:5: ( ' ' | '\\n' | '\\t' )+
    		# 45:5: ( ' ' | '\\n' | '\\t' )+
    		matchedOnce2 = false
    		while true
    		    alt2 = 2
    		    # 
    		    look_ahead2_0 = @input.look_ahead(1)
    		    look_ahead2_0 = -1 if look_ahead2_0 == :EOF
    		    if (look_ahead2_0 >= ?\t && look_ahead2_0 <= ?\n) || look_ahead2_0 == ?\s  
    		        alt2 = 1
    		    end
    		    case alt2
    		        when 1
    		            # 
    		            if (@input.look_ahead(1) >= ?\t && @input.look_ahead(1) <= ?\n) || @input.look_ahead(1) == ?\s
    		                match()
    		            else
    		                raise "Expected set"
    		            end
    		        else
    		            break
    		    end
    		    matchedOnce2 = true
    		end

    		if !matchedOnce2
    		    raise "Expected at least one match: 45:5: ( ' ' | '\\n' | '\\t' )+"
    		end
    		 channel = 99 
    end

    def match_Tokens()

    		# 1:8: ( T__6 | T__7 | T__8 | T__9 | T__10 | T__11 | NUMBER | WS )
    		alt3 = 8
    		# 
    		case @input.look_ahead(1)
    		    when ?+
    		        alt3 = 1
    		    when ?-
    		        alt3 = 2
    		    when ?*
    		        alt3 = 3
    		    when ?/
    		        alt3 = 4
    		    when ?(
    		        alt3 = 5
    		    when ?)
    		        alt3 = 6
    		    when ?0,?1,?2,?3,?4,?5,?6,?7,?8,?9
    		        alt3 = 7
    		    when ?\t,?\n,?\s
    		        alt3 = 8
    		    else
    		        raise "Expected: "

    		end
    		case alt3
    		    when 1
    		        # 1:10: T__6
    		        match_[SimpleCalc.T__6,index=1,line=7]()
    		    when 2
    		        # 1:15: T__7
    		        match_[SimpleCalc.T__7,index=2,line=8]()
    		    when 3
    		        # 1:20: T__8
    		        match_[SimpleCalc.T__8,index=3,line=9]()
    		    when 4
    		        # 1:25: T__9
    		        match_[SimpleCalc.T__9,index=4,line=10]()
    		    when 5
    		        # 1:30: T__10
    		        match_[SimpleCalc.T__10,index=5,line=11]()
    		    when 6
    		        # 1:36: T__11
    		        match_[SimpleCalc.T__11,index=6,line=12]()
    		    when 7
    		        # 1:42: NUMBER
    		        match_[SimpleCalc.NUMBER,index=7,line=43]()
    		    when 8
    		        # 1:49: WS
    		        match_[SimpleCalc.WS,index=8,line=45]()
    		end

    end


end